#Connor Twohey
#UTA ID: 1001177282

import sys
import os

#Current Working Directory
cwd = os.getcwd()
#IMPORTANT: If running on a windows machine, change each forward slash to a backwards slash
edgesFilePath = cwd + "/data/Edges.txt"
nodesFilePath = cwd + "/data/Nodes.txt"
routersFilePath = cwd + "/data/Routers.txt"
routesFilePath = cwd + "/paths/Routes.txt"

nodes = []
routers = []
edges = []

#Reading in Graph information
#In the code, routers are only represented using the number, not the entire string (R000x)
#This is simply done to simplify computations
with open(edgesFilePath, "r") as f:
	for line in f:
		lineSplit = line.split(' ')
		edge = [int(lineSplit[0][-1]), int(lineSplit[1][-1]), int(lineSplit[2])]
		edges.append(edge)

with open(nodesFilePath, "r") as f:
	for line in f:
		nodes.append(int(line))

with open(routersFilePath, "r") as f:
	for line in f:
		rNum = int(line[len(line)-2])
		routers.append(rNum)

#inf (infinity) used as default distance (D(v))
inf = float('inf')

#Return list of neighbor nodes/routers for node/router n
def neighbors(n):
	nbrs = []
	i = 0
	for x in edges:
		if n in edges[i]:
			if edges[i][0] == n and edges[i][1] not in nbrs:
				nbrs.append(edges[i][1])
			elif edges[i][1] == n and edges[i][0] not in nbrs:
				nbrs.append(edges[i][0])
		i+=1
	return nbrs

#Returns list containing pairs of nodes/routers (prevNodes)
#The first node/router is the current one, and the second one
#is the preceding node/router in the shortest path from the source
#to that current node/router. This list can be analyzed to find paths
#between nodes/routers in the graph. In a sense, this list can act as
#a forwarding table for the graph.
def dijkstra(source):
	if source in routers:
		print "You cannot use a Router as a source"
		return

	#Beginning of Initialization

	#nPrime holds nodes that definitively have a shortest path
	nPrime = [source]
	#distances holds all D(v) values; Elements in format of [n, d]
	#with n = node/router number, and d = distance
	distances = []
	#prevNodes holds the previous node in the optimal path from source
	#[Node/router, preceding node/router]
	prevNodes = []

	initNeighbors = neighbors(source)
	for v in initNeighbors:
		for i in xrange(len(edges)):
			if (edges[i][0] == source and edges[i][1] == v) or (edges[i][0] == v and edges[i][1] == source):
				d = edges[i][2]
				dist = [v, d]
				distances.append(dist)

	for i in xrange(len(nodes)):
		if nodes[i] not in initNeighbors and nodes[i] != source:
			dist = [nodes[i], inf]
			distances.append(dist)
	for i in xrange(len(routers)):
		if routers[i] not in initNeighbors:
			dist = [routers[i], inf]
			distances.append(dist)

	#Previous Distance container initialized to infinity for initial values
	#Also initializing prevNodes (previous nodes all given arbitrary initial value of inf)
	for i in xrange(len(distances)):
		pDist = [distances[i][0], inf]
		prevNodes.append(pDist)

	#End of Initialization

	w = 0
	#used to keep track of where in the distance vector w is located
	dNum = 0
	while len(nPrime) < (len(nodes) + len(routers)):
		#Arbitrary starting value
		wMin = inf
		for i in xrange(len(distances)):
			if distances[i][1] < wMin and distances[i][0] not in nPrime:
				wMin = distances[i][1]
				w = distances[i][0]
				dNum = i
		if w not in nPrime:
			nPrime.append(w)

		wN = neighbors(w)
		wNeighbors = [x for x in wN if x not in nPrime]

		for n in xrange(len(wNeighbors)):
			distW = distances[dNum][1]
			#Finding edge connecting w with neighbor n
			#And calculating alternate distance distW = (D(w) + c(w,n))
			added = 0
			for j in xrange(len(edges)):
				if ((edges[j][0] == wNeighbors[n] and edges[j][1] == w) or (edges[j][0] == w and edges[j][1] == wNeighbors[n])) and added == 0:
					distW += edges[j][2]
					added = 1

			#Finding current neighbor in distances list
			dSpot = 0
			for x in xrange(len(distances)):
				if distances[x][0] == wNeighbors[n]:
					dSpot = x


			if distW < distances[dSpot][1] or distances[dSpot][1] == inf:
				distances[dSpot][1] = distW
				prevNodes[dSpot][1] = w
	
	for i in xrange(len(prevNodes)):
		if prevNodes[i][0] != source and prevNodes[i][1] == inf:
			prevNodes[i][1] = source

	return prevNodes

#Takes a single [node, forwarding table] pair and a destination
#and constructs the path between them. Path is given in the form of
#a list, which will later be turned into a string for publishing by publish_paths
def find_path(ft, dest):
	table = ft[1]
	src = ft[0]
	path = [src, dest, src]
	#Used to keep track of which node we will move to in the next iteration
	nextNode = dest
	#Temporary container used to hold the values generated by the below loop.
	#The loop below does give the correct path, but it is backwards,
	#so it needs to be reversed before added to the path container.
	temp = []
	#Using forwarding table to work backwards from dest until we reach src
	srcFound = False
	while(srcFound == False):
		for i in xrange(len(table)):
			if table[i][0] == nextNode:
				temp.append(nextNode)
				nextNode = table[i][1]
			if nextNode == src:
				srcFound = True
	temp.reverse()
	path = path + temp
	return path

#Takes the list(s)/forwarding table(s) generated by dijkstra,
#Finds the paths between each pair of nodes (using find_path),
#formats the paths for proper output, and then writes to the Routes.txt file
def publish_paths(ft):
	paths = []
	for i in xrange(len(ft)):
		#temp is used to hold all the nodes for which a path to themselves
		#from source needs to be computed
		temp = []
		for j in xrange(len(nodes)):
			if nodes[j] != ft[i][0]:
				temp.append(nodes[j])

		for j in xrange(len(temp)):
			p = find_path(ft[i], temp[j])
			paths.append(p)
	
	with open(routesFilePath, "w") as f:
		#Holds the string that will be written into f (Routes.txt)
		for i in xrange(len(paths)):
			entry = ""
			for j in paths[i]:
				s = j
				if j in routers:
					s = "R" + str(j)
				entry = entry + str(s) + " "
			f.write(entry)
			f.write('\n')

#List of forwarding tables for the nodes (NOT routers)
#Forwarding tables labeled by node number.
tables = []
for s in nodes:
	tables.append([s, dijkstra(s)])

publish_paths(tables)

while True:
	with open(routesFilePath, "r") as f:
		cmd = raw_input("Please Enter a Command: ")
		if cmd == "list_all_paths":
			out = f.read()
			print(out)
		elif cmd.split(' ')[0] == 'list_path_to':
			cmdSplit = cmd.split(' ')
			if len(cmdSplit) < 3:
				print 'You are missing a source or a destination. Please try again'
				continue
			src = cmdSplit[1]
			dest = cmdSplit[2]
			if int(src) not in nodes or int(dest) not in nodes:
				print 'Source or Destination invalid. Please Try again'
				continue
			pathFound = False
			line = ""
			while pathFound == False:
				line = f.readline()
				lineSplit = line.split(' ')
				if lineSplit[0] == src and lineSplit[1] == dest:
					pathFound = True
			print(line)
		else:
			print 'Invalid command. Please try again.'